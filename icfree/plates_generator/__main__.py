'''
Plates generator module

This module generates source and destination plates from
volumes dataframes generated by sampler (or converter) module
'''
import sys
from os import (
    path as os_path,
    makedirs as os_makedirs
)

from brs_utils import (
    create_logger
)

from .plates_generator import (
    extract_dead_volumes,
    src_plate_generator,
    dst_plate_generator
)
from .args import build_args_parser
from .plate import Plate
from icfree.utils import save_df
from icfree.converter.__main__ import input_importer

# def input_importer(
#     cfps_parameters,
#     volumes,
#     logger: Logger = getLogger(__name__)
# ):
#     """
#     Create volumes dataframes from tsv files

#     Parameters
#     ----------
#     cfps_parameters : tsv file
#         TSV of cfps parameters, status, maximum and stock concentrations
#     volumes : tsv file
#         Dataset with volumes values

#     Returns
#     -------
#     cfps_parameters_df : DataFrame
#         Dataframe with cfps_parameters data
#     volumes_df : DataFrame
#         Dataframe with volumes data
#     """
#     cfps_parameters_df = read_csv(
#         cfps_parameters,
#         sep='[,\t]',
#         engine='python'
#     )
#     logger.debug(f'cfps_parameters_df: {cfps_parameters_df}')

#     volumes_df = read_csv(volumes, sep='[,\t]', engine='python')
#     logger.debug(f'volumes_df: {volumes_df}')

#     return cfps_parameters_df, volumes_df


def main():
    """
    Main function
    """
    parser = build_args_parser(
        program='plates_generator',
        description='Generates source and destination plates'
    )

    args = parser.parse_args()

    # CREATE LOGGER
    logger = create_logger(parser.prog, args.log)

    parameters_df, values_df = input_importer(
        args.parameters,
        args.volumes,
        logger=logger
    )

    values_df['Water'] = \
        args.sample_volume - values_df.sum(axis=1)

    # Exract dead plate volumes from cfps_parameters_df
    dead_volumes = extract_dead_volumes(
        parameters_df,
        logger=logger
    )

    # Generate destination plates
    dest_plates = dst_plate_generator(
        volumes=values_df,
        start_well=args.dst_start_well,
        well_capacity=args.dst_plt_well_capacity,
        vertical=True,
        nplicates=args.nplicates,
        dimensions=args.dst_plt_dim,
        logger=logger
    )

    # Generate source plates
    try:
        source_plates = src_plate_generator(
            # volumes=values_df,
            dest_plates=dest_plates,
            plate_dead_volume=args.src_plt_dead_volume,
            well_capacity=args.src_plt_well_capacity,
            param_dead_volumes=dead_volumes,
            start_well=args.src_start_well,
            opt_well_vol=args.opt_well_vol,
            vertical=True,
            dimensions=args.src_plt_dim,
            logger=logger
        )
    except IndexError as e:
        logger.error(e)
        logger.error(
            'Exiting...'
        )
        return -1

    # Save source plates
    # Create output folder if it does not exist
    if not os_path.exists(args.output_folder):
        os_makedirs(args.output_folder)
    for i in range(len(source_plates)):
        plt_name = f'{i+1}'
        source_plates[i].to_file(
            os_path.join(
                args.output_folder,
                f'source_plate_{plt_name}.{args.output_format}'
            ),
            args.output_format
        )

    # Save destination plates
    for i in range(len(dest_plates)):
        plt_name = f'{i+1}'
        dest_plates[i].to_file(
            os_path.join(
                args.output_folder,
                f'destination_plate_{plt_name}.{args.output_format}'
            ),
            args.output_format
        )

    # Save volumes summary
    volumes_summary = Plate.get_volumes_summary(
        source_plates,
        'pandas',
        logger=logger
    )
    save_df(
        df=volumes_summary,
        outfile='volumes_summary.tsv',
        output_folder=args.output_folder,
        index=True,
        logger=logger
    )


if __name__ == "__main__":
    sys.exit(main())
